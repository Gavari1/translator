<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Micro Dictionary</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #0b1020;
      color: #f5f5f5;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 2rem 1rem 3rem;
    }

    h1 {
      margin-bottom: 0.25rem;
      text-align: center;
    }

    .subtitle {
      opacity: 0.8;
      margin-bottom: 1.5rem;
      font-size: 0.95rem;
      text-align: center;
    }

    .card {
      background: #151a2b;
      border-radius: 12px;
      padding: 1.5rem;
      max-width: 920px;
      width: 100%;
      box-shadow: 0 12px 30px rgba(0, 0, 0, 0.45);
      border: 1px solid #272f47;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: flex-end;
      margin-bottom: 1rem;
    }

    .search-box {
      flex: 1 1 220px;
    }

    .mode-box {
      flex: 0 0 220px;
    }

    label {
      font-size: 0.85rem;
      opacity: 0.9;
      display: block;
      margin-bottom: 0.2rem;
    }

    input[type="text"], select {
      width: 100%;
      box-sizing: border-box;
      padding: 0.5rem 0.75rem;
      border-radius: 8px;
      border: 1px solid #272f47;
      background: #0f1423;
      color: #f5f5f5;
      font-size: 0.95rem;
    }

    input[type="text"]:focus, select:focus {
      outline: none;
      border-color: #3f82ff;
      box-shadow: 0 0 0 1px #3f82ff44;
    }

    .alpha-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 0.25rem;
      justify-content: flex-end;
      font-size: 0.8rem;
      width: 100%;
    }

    .alpha-btn {
      border-radius: 999px;
      padding: 0.2rem 0.5rem;
      border: 1px solid #272f47;
      background: #0f1423;
      color: #f5f5f5;
      cursor: pointer;
    }

    .alpha-btn:hover {
      background: #222842;
    }

    .alpha-btn.disabled {
      opacity: 0.35;
      cursor: default;
    }

    .dictionary {
      margin-top: 0.75rem;
      max-height: 70vh;
      overflow-y: auto;
      padding-right: 0.25rem;
    }

    .letter-section {
      margin-bottom: 1.25rem;
    }

    .letter-heading {
      font-size: 1.1rem;
      font-weight: 600;
      margin-bottom: 0.4rem;
      border-bottom: 1px solid #272f47;
      padding-bottom: 0.2rem;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9rem;
    }

    th, td {
      padding: 0.35rem 0.35rem;
      vertical-align: top;
    }

    th {
      text-align: left;
      font-size: 0.8rem;
      text-transform: uppercase;
      opacity: 0.7;
      border-bottom: 1px solid #272f47;
    }

    tr:nth-child(even) td {
      background: #111727;
    }

    .col-en {
      width: 40%;
      font-weight: 500;
    }

    .col-gv {
      width: 30%;
      color: #b8d1ff;
    }

    .col-notes {
      width: 30%;
      font-size: 0.8rem;
      opacity: 0.8;
    }

    .hint {
      margin-top: 0.9rem;
      font-size: 0.8rem;
      opacity: 0.75;
      line-height: 1.4;
    }

    @media (max-width: 700px) {
      .card {
        padding: 1.1rem;
      }

      .controls {
        flex-direction: column;
        align-items: stretch;
      }

      .alpha-bar {
        justify-content: center;
      }

      th.col-notes,
      td.col-notes {
        display: none;
      }

      .mode-box {
        flex: 1 1 auto;
      }
    }
  </style>
</head>
<body>
  <h1>Micro Dictionary</h1>
  <div class="subtitle" id="subtitle">English ➜ Micro · Official Canon Lexicon</div>

  <div class="card">
    <div class="controls">
      <div class="search-box">
        <label for="searchInput">Search (English or Micro)</label>
        <input
          id="searchInput"
          type="text"
          placeholder="Type to filter… e.g. 'coffee', 'cof', 'work', 'wor'"
        />
      </div>

      <div class="mode-box">
        <label for="modeSelect">View</label>
        <select id="modeSelect">
          <option value="en">English → Micro</option>
          <option value="mc">Micro → English</option>
        </select>
      </div>

      <div class="alpha-bar" id="alphaBar"></div>
    </div>

    <div id="dictionary" class="dictionary"></div>

    <div class="hint">
      <strong>How to update this page:</strong><br />
      Scroll to <code>dictionaryEntries</code> and add objects like:
      <code>{ english: "water", micro: "wat", notes: "Noun" }</code>.<br />
      The page auto-sorts A–Z by the selected view and groups by first letter.
    </div>
  </div>

  <script>
    // ---------------------------------------------
    // 1) OFFICIAL CANON WORD LIST (ENGLISH <-> MICRO)
    // ---------------------------------------------
    // Fields:
    //  - english (required)
    //  - micro   (required)
    //  - notes   (optional: category, usage)
    const dictionaryEntries = [
      // Pronouns
      { english: "I / me", micro: "go", notes: "Pronoun" },
      { english: "you / yours", micro: "lo", notes: "Pronoun" },
      { english: "he / she / it", micro: "po", notes: "Pronoun" },
      { english: "we / us / ours", micro: "wo", notes: "Pronoun" },
      { english: "they / them / theirs", micro: "to", notes: "Pronoun" },

      // States / Conditions
      { english: "good / okay", micro: "ka", notes: "State" },
      { english: "bad / not okay", micro: "na", notes: "State" },
      { english: "uncertain / not sure", micro: "un", notes: "State" },

      // Emotions / Physical state
      { english: "happy", micro: "hap", notes: "State" },
      { english: "tired", micro: "nap", notes: "State" },
      { english: "sick", micro: "ill", notes: "State" },
      { english: "hungry", micro: "hun", notes: "State" },

      // Conversation / Responses
      { english: "ok / agree", micro: "ok", notes: "Response" },
      { english: "yes", micro: "ya", notes: "Response" },
      { english: "please", micro: "pez", notes: "Response" },

      // Negation
      { english: "no / not", micro: "nok", notes: "Negation (all uses)" },

      // Questions
      { english: "question marker (optional)", micro: "qe", notes: "Question" },
      { english: "and you?", micro: "lo qe", notes: "Question / turn-back" },
      { english: "why", micro: "wah", notes: "Question" },
      { english: "how", micro: "kah", notes: "Question" },

      // Core verbs (no conjugation)
      { english: "go / move (generic)", micro: "fa", notes: "Verb" },
      { english: "stay", micro: "sta", notes: "Verb" },
      { english: "return / go back", micro: "ret", notes: "Verb" },
      { english: "eat", micro: "ek", notes: "Verb" },
      { english: "drink", micro: "dak", notes: "Verb" },
      { english: "drive", micro: "dri", notes: "Verb" },
      { english: "sleep", micro: "lep", notes: "Verb" },
      { english: "come", micro: "ome", notes: "Verb" },
      { english: "get", micro: "et", notes: "Verb" },
      { english: "make / do", micro: "mok", notes: "Verb" },
      { english: "walk", micro: "troka", notes: "Verb" },
      { english: "wake up", micro: "vakre", notes: "Verb" },
      { english: "finished / done", micro: "brent", notes: "Verb" },

      // Intent / Cognition / Ability
      { english: "want", micro: "wan", notes: "Mind" },
      { english: "need", micro: "nek", notes: "Mind" },
      { english: "think", micro: "tig", notes: "Mind" },
      { english: "can / able to", micro: "can", notes: "Mind" },
      { english: "know", micro: "ken", notes: "Mind" },
      { english: "see", micro: "seg", notes: "Mind" },

      // People
      { english: "child", micro: "kid", notes: "People" },
      { english: "person (any gender)", micro: "man", notes: "People" },
      { english: "friend", micro: "fen", notes: "People" },
      { english: "family", micro: "brann", notes: "People" },

      // Daily life
      { english: "work", micro: "wor", notes: "Daily" },
      { english: "money", micro: "pay", notes: "Daily" },

      // Nouns (places / things)
      { english: "boat", micro: "bok", notes: "Noun" },
      { english: "coffee", micro: "cof", notes: "Noun" },
      { english: "food", micro: "fod", notes: "Noun" },
      { english: "water", micro: "wat", notes: "Noun" },
      { english: "house", micro: "hus", notes: "Noun" },
      { english: "bed", micro: "bed", notes: "Noun" },
      { english: "key", micro: "keh", notes: "Noun" },
      { english: "bar", micro: "bar", notes: "Place / Noun" },
      { english: "restaurant", micro: "res", notes: "Place / Noun" },
      { english: "store", micro: "sto", notes: "Place / Noun" },
      { english: "car", micro: "car", notes: "Noun" },
      { english: "fish", micro: "fisk", notes: "Noun" },
      { english: "beer", micro: "beir", notes: "Noun" },
      { english: "computer", micro: "kuter", notes: "Noun" },
      { english: "group", micro: "gropa", notes: "Noun" },
      { english: "road", micro: "rodek", notes: "Noun" },
      { english: "shelter", micro: "svald", notes: "Noun" },
      { english: "warm", micro: "warn", notes: "Noun" },
      { english: "cold", micro: "snark", notes: "Noun" },

      // Location / Direction
      { english: "here", micro: "heg", notes: "Place" },
      { english: "there", micro: "the", notes: "Place" },
      { english: "at / located at", micro: "at", notes: "Place" },
      { english: "to / toward", micro: "ze", notes: "Direction" },
      { english: "away", micro: "awa", notes: "Direction" },
      { english: "back", micro: "bak", notes: "Direction" },

      // Time
      { english: "now", micro: "nar", notes: "Time" },
      { english: "today", micro: "tod", notes: "Time" },
      { english: "yesterday", micro: "yer", notes: "Time" },
      { english: "tomorrow", micro: "tom", notes: "Time" },
      { english: "later", micro: "lat", notes: "Time" },
      { english: "after", micro: "aft", notes: "Time" },
      { english: "time", micro: "tim", notes: "Time" },
      { english: "night", micro: "nit", notes: "Time" },
      { english: "morning", micro: "morn", notes: "Time" },
      { english: "still / yet", micro: "enda", notes: "Time" },

      // Connectors / prepositions
      { english: "and", micro: "og", notes: "Connector" },
      { english: "but", micro: "but", notes: "Connector" },
      { english: "because", micro: "cau", notes: "Connector" },
      { english: "also", micro: "aso", notes: "Connector" },
      { english: "if", micro: "if", notes: "Connector" },
      { english: "then", micro: "thu", notes: "Connector" },
      { english: "or", micro: "or", notes: "Connector" },
      { english: "maybe", micro: "mab", notes: "Connector" },
      { english: "from", micro: "fro", notes: "Connector" },
      { english: "with", micro: "wij", notes: "Preposition" },
      { english: "only / just", micro: "bare", notes: "Preposition" },
    ];

    // ---------------------------------------------
    // 2) RENDERING LOGIC (toggle English/Micro view)
    // ---------------------------------------------
    const dictionaryContainer = document.getElementById("dictionary");
    const searchInput = document.getElementById("searchInput");
    const alphaBar = document.getElementById("alphaBar");
    const modeSelect = document.getElementById("modeSelect");
    const subtitle = document.getElementById("subtitle");

    function normalize(str) {
      return (str || "")
        .toLowerCase()
        .normalize("NFD")
        .replace(/[\u0300-\u036f]/g, "");
    }

    function buildGroupedDictionary(entries, mode) {
      const key = mode === "mc" ? "micro" : "english";
      const groups = {};

      for (const entry of entries) {
        const firstChar = (entry[key] || "").trim().charAt(0).toUpperCase();
        const letter = /[A-Z]/.test(firstChar) ? firstChar : "#";
        if (!groups[letter]) groups[letter] = [];
        groups[letter].push(entry);
      }

      for (const letter in groups) {
        groups[letter].sort((a, b) =>
          (a[key] || "").toLowerCase().localeCompare((b[key] || "").toLowerCase())
        );
      }

      return groups;
    }

    function renderDictionary(filter = "", jumpToLetter = null) {
      const mode = modeSelect.value; // "en" or "mc"
      subtitle.textContent = mode === "mc"
        ? "Micro ➜ English · Official Canon Lexicon"
        : "English ➜ Micro · Official Canon Lexicon";

      const normFilter = normalize(filter);

      const filtered = dictionaryEntries.filter((entry) => {
        if (!normFilter) return true;
        const en = normalize(entry.english);
        const mc = normalize(entry.micro);
        const notes = normalize(entry.notes || "");
        return en.includes(normFilter) || mc.includes(normFilter) || notes.includes(normFilter);
      });

      const groups = buildGroupedDictionary(filtered, mode);
      const letters = Object.keys(groups).sort();

      dictionaryContainer.innerHTML = "";

      if (filtered.length === 0) {
        dictionaryContainer.innerHTML =
          "<p style='opacity:0.7;font-size:0.9rem;'>No entries found for that search.</p>";
        return;
      }

      const fragment = document.createDocumentFragment();

      letters.forEach((letter) => {
        const section = document.createElement("section");
        section.className = "letter-section";
        section.id = `letter-${letter}`;

        const heading = document.createElement("div");
        heading.className = "letter-heading";
        heading.textContent = letter === "#" ? "#" : letter;
        section.appendChild(heading);

        const table = document.createElement("table");

        const thead = document.createElement("thead");
        thead.innerHTML = `
          <tr>
            <th class="col-en">${mode === "mc" ? "Micro" : "English"}</th>
            <th class="col-gv">${mode === "mc" ? "English" : "Micro"}</th>
            <th class="col-notes">Notes</th>
          </tr>
        `;
        table.appendChild(thead);

        const tbody = document.createElement("tbody");
        groups[letter].forEach((entry) => {
          const tr = document.createElement("tr");
          const leftTd = document.createElement("td");
          const rightTd = document.createElement("td");
          const notesTd = document.createElement("td");

          leftTd.className = "col-en";
          rightTd.className = "col-gv";
          notesTd.className = "col-notes";

          // Swap columns depending on mode
          leftTd.textContent = mode === "mc" ? entry.micro : entry.english;
          rightTd.textContent = mode === "mc" ? entry.english : entry.micro;
          notesTd.textContent = entry.notes || "";

          tr.appendChild(leftTd);
          tr.appendChild(rightTd);
          tr.appendChild(notesTd);
          tbody.appendChild(tr);
        });

        table.appendChild(tbody);
        section.appendChild(table);
        fragment.appendChild(section);
      });

      dictionaryContainer.appendChild(fragment);

      if (jumpToLetter && document.getElementById(`letter-${jumpToLetter}`)) {
        document.getElementById(`letter-${jumpToLetter}`)
          .scrollIntoView({ behavior: "smooth", block: "start" });
      }
    }

    function renderAlphaBar() {
      // Alpha bar should follow the current view key (English or Micro)
      const mode = modeSelect.value;
      const key = mode === "mc" ? "micro" : "english";

      const lettersInUse = new Set(
        dictionaryEntries.map((e) => {
          const c = ((e[key] || "").trim().charAt(0).toUpperCase() || "#");
          return /[A-Z]/.test(c) ? c : "#";
        })
      );

      const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
      alphaBar.innerHTML = "";

      letters.forEach((letter) => {
        const btn = document.createElement("button");
        btn.textContent = letter;
        btn.className = "alpha-btn";

        if (!lettersInUse.has(letter)) {
          btn.classList.add("disabled");
        } else {
          btn.addEventListener("click", () => {
            renderDictionary(searchInput.value, letter);
          });
        }

        alphaBar.appendChild(btn);
      });
    }

    searchInput.addEventListener("input", () => {
      renderDictionary(searchInput.value);
    });

    modeSelect.addEventListener("change", () => {
      renderAlphaBar();
      renderDictionary(searchInput.value);
    });

    renderAlphaBar();
    renderDictionary("");
  </script>
</body>
</html>
